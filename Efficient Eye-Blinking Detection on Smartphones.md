# 스마트폰에서 효율적인 눈 깜박임 탐지
##### Copyright © 2018 Young-Joo Han et al. This is an open access article distributed under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.
---
본 논문에서는 스마트폰 플랫폼에서 눈 깜박임 탐지 또는 눈 추적에 사용할 수 있는 효율적인 방법을 제안한다. 눈 깜박임 탐지 또는 눈 추적 알고리즘은 모바일 환경에서 다양한 응용 프로그램을 사용한다. 예를 들어, 얼굴 인식 시스템 스푸핑 방지가 있다. 리소스가 제한된 스마트폰 환경에서 눈 깜박임 검출의 핵심 문제는 계산 효율 문제이다. 문제를 해결하기 위해 두 가지 머신 러닝 기술을 이용한다. SVM과 CNN을 사용하여 눈 깜박임 검출을 리소스가 제한된 스마트폰에서 효율적이고 안정적으로 수행할 수 있다. 실험 결과 스마트폰은 우리의 접근 방식이 FPS 22의 처리속도를 가지고 94.4%의 정밀도를 달성한다.

## 목차
1. [Introduction](##Introduction)

2. [Related Works](#Related-Works)

3. [Propsed Algorithm](#Propsed-Algorithm)

4. [Evaluation](#Evaluation) (미완입니다.)

5. [Conclusion](#5.-Conclusion)

## 1. Introduction
Eye-tracking이나 깜빡임 검출 알고리즘은 스마트폰 플랫폼에 다양한 응용 프로그램이 있습니다. 예를 들어 얼굴 인식 시스템에서 스푸핑에 대한 대책으로 사용될 수 있다[1]. 또한 많은 스마트폰 사용자들이 겪고 있는 컴퓨터 비전 증후군[2]은 눈 깜빡임 검출 시스템이 그들의 눈 깜빡임 습관에 관해 사용자들에게 조언을 제공할 때 완화될 수 있다. 

비디오 입력에 기반한 Eye-tracking 및 눈 깜빡임 검출 알고리즘에는 많은 연구가 있다. 예를 들어[3-8], 그러나 데스크톱 환경을 위해 개발된 기법은  스마트폰의 계산 자원의 한계와 사용자 움직임으로 입력된 비디오 프레임 내의 눈의 위치의 빈번한 변화로 인해 모바일/스마트폰 환경에서 제대로 작동하지 않을 수 있다. 이런 문제를 해결하는 한가지 방법은 관심 영역(ROI, Region of Interest)을 이용하는 것이다. 예를 들어[7], 각 비디오 프레임의 전체 영역에서 눈을 검색하는 대신에, ROI라는 작은 영역을 검사한다. 모든 비디오 프레임의 전체 영역에서 눈을 위치시키는 것은 시간과 에너지를 소비하므로 스마트폰에서 실시간 처리하기에는 적합하지 않다. ROI 기반 솔루션에서 ROI를 설정하는 방법은 시스템 성능의 핵심이며 모바일 환경에서 문제가 더 어려워진다. 예를 들어[7], 일부 구성표는 가속도계와 같은 내장형 센서를 사용하여 입력 비디오 프레임에서 눈의 위치를 효과적으로 예측하여 동적 모바일 환경에서 실시간으로 Eye-tracking을 구현한다.

최근에 스마트폰을 위한 eye-tracking 알고리즘에 기반한 몇가지 깊은 CNN이 제안됐다. 지난 몇년동안 다양한 컴퓨터 비전 문제를 해결하기 위해 깊은 CNN 모델이 성공적으로 적용되었지만 스마트폰에서 깊은 CNN 모델을 실행하는 것은 계산 복잡성으로 인해 여전히 어려운 것으로 간주된다. 특히 눈 깜빡임 검출에 관해서는 눈 깜박임 검출 문제가 보다 엄격한 실시간 요구 사항, 즉 FPS가 10 이상의 처리속도를 요하기 때문에 eye-tracking보다 더 계산적으로 효율적이어야한다. 이 문제를 해결하기 위해, 우리는 두가지 머신 러닝 기술을 결합한 하이브리드 접근법인 HOG(Histogram of Oriented Gradients) 특징[9]의 막대 그래프가 있는 SVM 분류기와 LeNet-5[10]라는 깊은 CNN 모델을 사용하여 눈 깜빡임 검출이 가능하다. 리소스가 제한된 스마트폰에서 효율적이고 안정적으로 수행된다. SVM 분류기는 빠르지만 덜 정확하다. 깊은 CNN 모델은 정확하지만 느리다. 따라서 우리의 계획에서 두개는 눈 깜빡임 검출에서 효율성과 정확성을 달성하기 위해 결합된다. 다시 말해 우리는 물체 감지에서 지역 제안 방법으로 SVM 탐지기를 사용한다. 눈 깜빡임 탐지 알고리즘에서 눈 깜빡임 감지 보고가 실제 깜빡임이 없었음에도 보고가 되는 False-Negative 탐지가 문제가 된다는 것을 알 수 있다. 예를 들어, 눈 깜빡임 탐지를 기반으로 하는 CVS 자문 시스템은 시스템이 F-N 탐지에 깜빡임 횟수를 포함해서 과대 평가할 경우 적절한 조언을 제공할 수 없다. 또한 F-N 탐지는 얼굴 인식 시스템에서 권고가 안티 스푸핑 매커니즘에 기반한 깜빡임 검출을 우회하도록 한다. 우리의 알고리즘은 F-N 탐지를 가능한 최소화하도록 설계됐다.

또한 모바일 환경에 적합한 새로운 ROI 선택 기법을 제안한다. 우리의 설계에서 ROI는 방향 센서의 판독값을 기반으로 동적으로 결정되고 ROI 위치와 방향 센서 판독값을 상호 연관시키기 위해 실시간 회귀 분석(Real-Time Regression Analysis)을 수행한다. 상용 스마트폰에 대한 실험 결과에 따르면 우리의 접근 방식은 기존 솔루션을 구현하는 것보다 약 25% 향상됐다.

이 논문은 다음과 같이 구성됐다. Section 2에서 관련 연구에 대해 논의한다. Section 3에서는 눈 추적 및 눈 깜빡임 탐지 시스템의 맥락에서 우리의 제안을 소개한다. Section 4에서는 제안된 알고리즘의 성능을 논의하고 기존의 솔루션과 비교한다. 마지막으로 Section 5에서 결론을 도출한다. 

## [Related Works](#목차)

이 섹션에서는 관련된 작업에 대해 설명한다. 눈 추적 및 탐지는 인간 행동, 인간-컴퓨터 상호 작용(HCI), 장애인 및 의학적 목적을 이해하기 위해 광범위하게 연구되었다. 간섭적 방법과는 달리, 적외선 조명[11, 12], 추가 하드 웨어가 필요 없는 nonintrusive 방식 및 물리적 접촉은 컴퓨터 비전 및 이미지/비디오 연구 분야에서 많은 주목을 받았다. [13-16]에 따르면, nonintrusive한 방법은 템플릿 기반 [13-19], 외형 기반[13,15,20,21], 피처 기반 방법[22,23] 등 여러가지 방법으로 분류할 수 있다. 그리고 그 중 일부는 하이브리드 방식으로 섞여 있다.

템플릿 기반 방법은 눈 모양으로 디자인된 일반적인 눈 모델의 템플릿과 일치하는 눈 이미지를 검색한다. 이미지에서 눈의 가장 좋은 표현에 맞게 변형될 수 있는 변형 가능한 템플릿은 주로 탐지 정밀도에 사용되지만, 초기 단계에서 적절하게 캡쳐된 눈 모델이 필요하다[13-16, 23]. 외형 기반 방법에서 눈 모델 및 특징 없이 원본 이미지의 학습된 세트를 기반으로 눈을 감지한다. 뉴런 네트워크나 SVM 머신과 같은 학습된 분류기는 다양한 얼굴 방향 및 조명 조건에서 눈을 탐지하는데 사용된다[24].
Zhu와 Ji는 eye glasses와 일광과 같은 잘 알려진 문제가 있는 적외선(IR) 기반의 눈 탐지 방식에서 학습된 분류기를 선택했다. 피처 기반의 방법은 눈 주변의 독특한 특징, 예를 들어 눈 자체의 경계 대신에 눈꺼풀 가장자리와 홍채의 강도 또는 색을 사용한다. 
Kawato와 Ohya[22]는 두 눈 사이의 특징점(즉, 두개의 어두운 부분의 중간 점)을 눈 탐지 및 추적에 사용하여 보다 안정적이었다. 
Tian[25]은 머리 방향에 따라 사용할 수 없더라도 Kanade-Lucas Tracking(KLT) 알고리즘의 수정된 버전을 사용하여 눈 안쪽 구석과 눈꺼풀의 특징 검출을 제안했다. 
Viloa-Jones 알고리즘[26]은 Haar 피처 기반의 계단식 분류기를 사용하여 Haar 피처(눈의 두 부분이 어두운 2 또는 3개의 직사각형)를 사용하여 효과적으로 눈 이미지를 검색할 수 있다. Cascading(연속적인) 연산은 계산 오버헤드를 줄이고 눈 이미지를 포함할 가능성이 높은 서브 윈도우 중 하나에서 감지 계산에 초점을 맞출 수 있다. 처음에 슬라이딩하는 첫번째 윈도우는 2 피처 분류자를 사용하여 서브 윈도우를 잡아내고, 서브 윈도우 내의 분류자에 대해 더 많은 피처를 고려한다. Viola-Jones 알고리즘은 OpenCV에 구현이 되어있어 널리 사용된다[27]. 
눈 탐지 외에 눈 깜빡임 검출을 위해, Grauman[28]은 온라인으로 생성된 open-eye 템플릿을 사용해 템플릿 기반 방법을 제안한 후 깜빡임 탐지를 위해 실제 이미지와 매칭시켰다. 그들은 실제 깜빡이는 눈과 눈 템플릿 사이의 유사성을 측정하는 상관 관계 점수를 도입했으며, 눈 깜빡임 기간동안 상관 계수가 감소했다. 
Chau와 Betke[22]는 온라인 템플릿과 실제 눈 이미지의 상관 관계 점수를 기반으로 깜빡임과 그것의 지속시간을 발견했다.

PC의 USB 카메라로 촬영된 320x240 해상도 비디오를 사용한 실험에서 2.8 GHz 펜티엄 4 및 1GB 메모리 PC를 사용하는 실시간 눈 깜빡임 검출은 자연스럽게 깜빡일 경우 약 95%의 정확도를 보였으나 의도적인 깜빡임은 15% 정도의 오차를 보였다.

Polastek[20]은 눈의 깜빡임 검출에 대한 두가지 방법을 제안했다. 제시된 알고리즘 중 첫번째는 1D 채도와 2D 채도의 히스토그램으로부터 역 투영을 계산하는 것이다. 두번째 방법은 KLT 알고리즘을 사용하여 안쪽 움직임 감지를 통해 눈꺼풀 움직임을 감지하는 것이다. Malik과 Smolka[30]는 눈 깜빡임 탐지를 위해 원본 로컬 바이너리 패턴을 향상시켰다. bin 히스토그램에 대한 균일한 패턴만을 사용하고 KLD(Kullback-Leibler Divergence)를 사용하여 감은 눈과 뜬 눈의 히스토그램 차이를 유도하여 탐지 정확도를 거의 10% 향상시킬 수 있다. Jennifer와 Sharmila[31]은 눈 깜빡임 검출을 위해 여러 알고리즘(즉 픽셀 수, 캐니 필터, 그래디언트 크기 및 LoG(Laplace of Gaussian))의 성능을 비교했다. 그들은 처음에 Viola-Jones 알고리즘에 의해 눈의 영역을 감지하고 그 알고리즘을 사용하여 눈을 감았는지 확인했다. 실험에 따르면 알고리즘은 픽셀 카운팅을 제외하고는 정확도면에서 비교가 가능하다. 거의 90%의 검출 정확도가 있다. 이 알고리즘에서는 상안과 하안의 차이를 고려하면 5% 이상 향상될 수 있다.

스마트폰이 컴퓨터 비전 증후군의 주요 원인이 됨에 따라 스마트폰에서 눈 깜빡임 검출에 대한 여러개의 연구가 소개 되었다. EyePhone[4]은 스마트폰의 전면 카메라를 컴퓨터-폰 인터페이스로 사용하여 눈 깜빡임을 검출하기 위해 제안됐다. 여기서 스마트폰 카메라 방향이 손의 움직임에 따라 다양하기 때문에 눈에 대한 각도에 따라 서로 다른 상관 관계 값을 사용하여 [18]에서 상관 관계 계수를 골랐다. 또한 저자는 계산 복잡도를 줄이기 위해 더 큰 ROI 윈도우를 제안했다. 400MHz 프로세서 코어 및 128MB RAM을 갖춘 Nokia N810을 사용한 실험에서 깜빡임 감지의 거의 75%가 달성되었으며 프로세스 지연은 CPU 및 RAM의 리소스 소비량을 65%, 56%으로 하며 약 100ms가 걸렸다. 여기서 스마트폰과 얼굴 사이의 거리가 20cm 이상이면 정확도가 떨어지고 40cm 이상은 작동하지 않는다. EyeGuardian[7]은 스마트 장치의 가속장치 모션 센서를 사용하여 연속적인 비디오 프레임에서 눈의 위치를 추적하는 기술을 소개했다.  눈 탐지 단계에서 EyeGuardian은 Viola-Jones 알고리즘을 사용하여 눈 영역을 검색하고 눈 주위에 작은 ROI를 유지하여 다음 비디오 프레임에서 계산 및 에너지를 줄인다. 손의 움직임으로 인해 ROI에서 눈을 잃은 추적 단계에서 가속장치의 감지 정보를 기반으로 새로운 위치를 추적한다. EyeGuardian은 추적 단계에서 높은 성공률을 보였고, 추적하지 않은 경우 80%를 보인것과 비교하면 90% 전후의 기록을 보여준다.

우리의 탐지 알고리즘은 HOG 특징[9]와 함께 선형 SVM을 사용한다. HOG 특징을 갖는 선형 SVM은 요즘 컴퓨터 비전 분야에서 가장 널리 사용되는 객체 검출기 중 하나이다. SVM+HOG는 여러가지 안구 감지 시스템에서 사용되어 왔다[17]. [17]에서 HOG 기반의 새로운 기술 "주요 지향성 그래디언트의 멀티 스케일 히스토그램"(multiscale histograms of principal-oriented gradients)이 제안됐다. 이 기술은 Viola-Jones 알고리즘과 같은 다른 특징 기술자(descriptor)와 결합하여 눈을 위치시키고 **근접성**을 감지한다. 그러나 선형 SVM은 기본적으로 이진 분류자이므로 직관적인 SVM+HOG 구현은 눈 깜빡임 감지 시스템으로 사용할 수 없다. 이 문제를 해결하기 위해 SVM+HOG와 LeNet-5 CNN 모델을 결합한 하이브리드 방식을 택했다. 우리의 접근법에서 우리는 눈을 찾기 위해 SVM+HOG 기술을 사용하고 탐지된 눈이 열렸는지 아니면 닫혔는지를 식별하기 위해 LeNet-5라고 하는 Deep CNN 모델을 사용한다.

최근에 눈 추적을 위해 Deep CNN을 사용하여 몇가지 연구가 수행됐다[8, 32]. 지난 몇 년 동안 다양한 CNN 모델을 성공적으로 적용하여 컴퓨터 비전 문제를 해결했지만 스마트폰에서 CNN 모델을 실행하는 것은 계산상의 복잡성으로 인해 여전히 어려움을 겪고 있다. 특히 눈 깜빡임 검출에 관해서는, 눈 깜빡임 검출 문제가 엄격한 실시간 요구 사항, 즉 초당 10프레임 이상의 처리 속도를 요하기 때문에 Deep CNN 기술의 적용 가능성이 보다 제한적이다. Eye-tracking 문제보다 계산적으로 더 효율적이어야한다. [32]의 저자는 뜬 눈과 감은 눈의 분류를 위한 ResNet-50[33]이라 불리는 CNN 모델을 사용하여 조사했지만, Geforce GTX 1070과 같은 완전히 갖춰진 데스크톱 PC가 필요하다. 우리의 계획은 스마트폰에서 10 FPS 이상의 처리속도를 달성할 수 있도록 LeNet-5[10]라고 하는 Deep CNN 모델을 사용한다. 상용 스마트폰은 계산 능력이 제한적이다. 예를 들어 삼성의 Galaxy Note 5 스마트폰에는 그래픽/쉐이더 코어가 16개가 있지만, Geforce GTX 1070 GPU에는 1920개가 있다. 따라서 스마트폰을 대상으로 하는 CNN 모델은 눈 깜빡임 감지 문제로 인한 실시간 요구사항을 달성하기 위해 계산 효율이 뛰어나야 한다. LeNet-5는 작은 메모리 공간과 계산 효율성으로 인해 선택됐다. LeNet-5 CNN 모델은 AlexNet[34], VGG-16/19[35], GoogLeNet[36], ResNet-50과 같은 이미지 분류 목적을 위해 개발된 최근의 Deep CNN 모델에 비해 훨씬 적은 수의 매개변수를 유지한다.(훨씬 높은 추론/처리 속도를 의미한다.) LeNet-5는 32x32의 흑백 이미지를 입력으로 받아들이는 반면 AlexNet, ResNet-50의 입력은 224x224의 컬러(RGB) 이미지다. 실제 숫자를 비교해보면 AlexNet에는 약 6천만개의 매개변수가 있고, ResNet-50에는 약 2천 5백만개의 매개변수가 있다. Lenet-5의 경우 100K개의 매개변수를 갖는다. AlexNet의 많은 양의 매개변수 때문에 AlexNet 또는 ResNet-50을 스마트폰에서 실시간으로 눈 깜빡임 탐지에 사용하는 것은 매우 어려운 일이다. LeNet-5는 3개의 Conv층과 2개의 Pooling층을 포함하여 7개의 층으로 구성된다. LeNet-5 구현에서 [10]에서처럼 Activation 함수로 tanh 함수 대신 ReLU Activation 함수가 사용된다.

## [Propsed Algorithm](#목차)
이 섹션에서는 스마트폰에서 효율적이고 안정적인 눈 깜빡임 감지 알고리즘을 설명한다.

3.1. **ROI에서 눈을 감지하고 눈 깜박임 횟수 세기.**
우리의 탐지 알고리즘은 영역 제안 단계와 검증 및 분류 단계 두 단계로 구성된다. 스마트폰의 내장 카메라에서 오는 비디오/사진 프레임이 연속적으로 있는 경우 각 프레임이 하나씩 처리된다. 영역 제안 단계에서 주어진 ROI에서 후보 영역을 추출하기 위해 HOG 특징을 갖는 선형 SVM 분류자를 이용한다.(ROI 설정 방법은 나중에 설명한다.) SVM 기반 탐지기는 스케일링 문제를 처리하기 위해 25x25, 28x28 및 31x31 크기의 세가지 슬라이딩 윈도우를 사용하여 ROI를 스캔한다. 즉, 눈의 크기는 카메라와 눈 사이의 거리에 따라 달라질 수 있다. Nonmaximum suppression 기술을 사용하여 최상의 점수를 가진 28x28 픽셀 영역이 후보 영역으로 선택된다. 

![Image](https://i.imgur.com/CWgpSxo.png)

그림 1은 Nonmaximum suppression 기술의 시각화된 예를 보여준다. 그림에서 붉은 영역은 가장 점수가 높고 후보 영역으로 선택된 영역이다. 검출된 눈이 떴는지 감겼는지 확인하고 False-Positive를 억제하기 위해 후보 지역을 LeNet-5 CNN 모델에 전달한다. 우리의 LeNet-5 CNN 모델 구현은 입력 이미지를 뜬 눈, 감은 눈, 배경의 세가지 범주로 구별한다. LeNet-5가 입력을 배경으로 분류하면 SVM이 눈을 찾을 수 없는 잘못된 영역을 선택했을 가능성이 크다. 이전에 언급했듯이, 눈 깜빡임 감지 알고리즘에서는 눈 깜빡임이 없을 때 눈을 깜빡였다고 감지하는 오류가 많이 발생하므로 하이브리드 알고리즘은 F-N 탐지를 최소화하는데 초점을 맞춘다. 또한 선형 SVM은 기본적으로 이진 분류자이므로 SVM을 눈과 배경을 구별하게 하고, LeNet-5 모델이 감지된 눈이 감겼는지를 체크하게 한다. SVM과 CNN을 결합하는 방법에 대한 직접적인 대안은 멀티 클래스 SVM을 사용하는 것이다. 평가 섹션의 실험 결과를 사용하여 정확도 측면에서 멀티 클래스 SVM에 대한 하이브리드 접근 방식을 비교한다. 

</br>**3.2. 학습 과정.**

SVM과 LeNet-5 두가지 탐지기/분류기 구성요소가 있다. 우리는 배경 클래스에 대한 이미지 클립의 무작위 컬렉션과 CEW의 조합인 LIBSVM[37]과 Caffe[38]를 사용하여 두 클래스를 개별적으로 학습할 것이다. CEW 데이터 세트는 뜬 눈과 감은 눈의 이미지 클립으로 구성된다. SVM 교육 프로세스에서 사용되는 데이터 세트에서 뜬 눈과 감은 눈의 이미지(총 9692개의 이미지)는 Positivie 클래스를 구성하고 9810개의 배경 이미지는 Negative 클래스를 구성한다. LeNet-5 Classifer 학습에는 뜬 눈, 감은 눈, 배경의 세가지 레이블이 있는 이미지가 사용된다. 4924개의 이미지는 뜬 눈, 4870 이미지는 감긴 눈으로, 4905개의 배경 이미지가 있다. Caffe를 사용하여 LeNet-5를 학습시킬때 우리는 Adam solver, 50000번의 반복, Learning rate 0.001, L2 Regularization을 사용했다.

</br>**3.3. ROI 선택.**

![Image](https://i.imgur.com/ShQcR7I.png)

그림 2에 보여지듯이, 탐지 시스템은 탐지 단계와 추적 단계 두가지 단께로 이루어지며, ROI 선택 매커니즘은 단계에 따라 다르다. 시스템의 초기 상태는 탐지 단계이다. 탐지 단계에서 ROI는 각 비디오 프레임의 전체 영역으로 설정된다. 우리는 240x360의 비디오 입력 해상도를 사용한다. 감지 단계에서 하이브리드 감지 방법을 사용하여 눈이 감지되면 ROI는 눈의 위치를 중심으로 79x106 영역(전체 프레임의 1/9)으로 설정된다. 작은 ROI 영역은 효율적인 탐지를 가능하게 한다. ROI가 설정되면, 추적 단계로 전환된다. 추적 단계에서는 ROI에서만 눈을 검색한다. 눈의 궤적을 놓친 경우, 즉 감지 알고리즘에서 눈을 찾지 못했다면, 방향 센서의 값을 기반으로 한 예측에 따라 눈의 위치를 예측하고 ROI를 재배치한다. 

</br>**3.4. 회귀 분석을 이용한 눈의 위치 예측.**

추적 단계에 ROI에서 눈을 찾지 못하면 눈의 위치를 예측하기 위해 방향 센서에서 판독값을 사용한다.(방향 센서를 내장된 하드웨어 가속도계 및 지자기장 센서의 판독값을 사용하여 장치의 방향을 계산하는 Java 코드의 부분으로 구현된 가상(소프트웨어 기반) 센서라고 부른다.) 그러나 방향 센서의 판독값은 스마트폰에서 스마트폰으로 다양하며 각 사용자마다 다른 폰 사용 습관이 있다. 따라서 우리는 실시간 회귀 분석을 사용하여 방향 센서와 눈 위치에서 입력 값을 상호 연관 시킨다[40]. 눈이 감지되면(어떤 단계에서든), 그 위치는 방향 센서의 판독값과 함께 저장된다. 저장된 데이터는 실시간 회귀 분석에 사용된다. 우리는 눈의 수평(수직) 위치가 방향 센서의 Y축(X축) 값과 관련이 있음을 발견했다. 눈의 위치를 예측하기 위한 회귀 분석을 사용하기 위해 (실시간으로) 저장된 튜플 데이터로부터 선형 회귀 방정식을 유도한 다음 가장 최근의 센서 값을 회귀 방정식에 적용하여 눈의 예상 위치를 알아낸다. 예상되는 눈의 위치를 기반으로 ROI를 재설정한다. ROI를 재설정한 후에는 새로운 ROI에서 눈을 찾아본다. 눈이 발견되면 추적 단계에 남아있고, 감지되지 않는다면 탐지 단계로 다시 전환한다. 즉 입력 비디오 프레임 전체 영역에서 눈을 감지한다.

## [Evaluation](#목차)

## [Conclusion](#목차)
본 논문에서는 머신러닝 기술 HOG 기능을 가진 선형 SVM 분류기와 Lenet-5 CNN 모델을 결합한 하이브리드 방식을 제안하여 리소스가 제한된 스마트폰에서 눈 깜빡임 검출을 효율적이고 안정적으로 수행할 수 있도록 했다. 또한 스마트폰의 Eye-tracking 응용 프로그램에서 효과적인 ROI 선택을 위한 회귀 기반 센서 활용 전략을 도입했다. 실험 결과를 통해 우리의 방법이 눈 깜빡임 검출을 기존의 방법보다 효율적이고 효과적으로 수행한다는 것을 볼 수 있었다. 시스템 성능으로 인해 크고 다양한 학습 데이터 셋으로 성능을 향상시키고 알고리즘의 정확성을 검증이 남았는데, 이것은 다른 학습 및 테스트 데이터 셋, 더 높은 처리 속도를 위한 안드로이드 구현의 최적화에 따라 크게 달라질 수 있다.

